generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

model Team {
  id        String     @id @default(cuid())
  name      String     @unique
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt
  tickets   Ticket[]
  users     UserTeam[]

  @@map("teams")
}

model User {
  id            String         @id @default(cuid())
  username      String         @unique
  email         String?        @unique
  password      String
  role          UserRole       @default(USER)
  isActive      Boolean        @default(true)
  companyId     String?        // Multi-tenant company association
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  teamId        String?
  requests      Request[]
  notes         TicketNote[]
  tickets       Ticket[]
  assignedTickets Ticket[]   @relation("AssignedTickets")
  teams         UserTeam[]
  notifications Notification[]
  workLogs      WorkLog[]
  company       Company?       @relation("CompanyUsers", fields: [companyId], references: [id])
  // Chat relations
  conversations ConversationParticipant[]
  sentMessages  Message[]      @relation("MessageSender")
  readReceipts  MessageReadReceipt[]
  presence      UserPresence?

  @@index([companyId])
  @@map("users")
}

model UserTeam {
  id        String   @id @default(cuid())
  userId    String
  teamId    String
  createdAt DateTime @default(now())
  team      Team     @relation(fields: [teamId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, teamId])
  @@map("user_teams")
}

model Branch {
  id           String         @id @default(cuid())
  name         String
  branchNumber String         @unique
  category     BranchCategory
  createdAt    DateTime       @default(now())
  updatedAt    DateTime       @updatedAt
  tickets      Ticket[]

  @@map("branches")
}

model Ticket {
  id                String          @id @default(cuid())
  userId            String
  branchId          String?
  manualBranchName  String?
  priority          Priority
  issue             String
  additionalDetails String?
  status            TicketStatus    @default(PENDING)
  createdAt         DateTime        @default(now())
  updatedAt         DateTime        @updatedAt
  incNumber         String?
  teamId            String?
  assignedToUserId  String?
  localContactName  String?
  localContactEmail String?
  localContactPhone String?
  timezone          String?
  attachments       Attachment[]
  statusHistory     StatusHistory[]
  notes             TicketNote[]
  workLogs          WorkLog[]
  messages          Message[]
  branch            Branch?         @relation(fields: [branchId], references: [id], onDelete: Cascade)
  team              Team?           @relation(fields: [teamId], references: [id])
  user              User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  assignedTo        User?           @relation("AssignedTickets", fields: [assignedToUserId], references: [id])

  @@map("tickets")
}

model StatusHistory {
  id        String       @id @default(cuid())
  ticketId  String
  status    TicketStatus
  note      String?
  adminNote String?
  createdAt DateTime     @default(now())
  ticket    Ticket       @relation(fields: [ticketId], references: [id], onDelete: Cascade)

  @@map("status_history")
}

model Attachment {
  id         String   @id @default(cuid())
  ticketId   String
  fileName   String
  fileUrl    String
  fileSize   Int
  mimeType   String
  uploadedAt DateTime @default(now())
  ticket     Ticket   @relation(fields: [ticketId], references: [id], onDelete: Cascade)

  @@map("attachments")
}

model Request {
  id          String              @id @default(cuid())
  userId      String
  title       String
  description String
  projectId   String?
  requestNumber String?
  status      RequestStatus       @default(PENDING)
  createdAt   DateTime            @default(now())
  updatedAt   DateTime            @updatedAt
  attachments RequestAttachment[]
  history     RequestHistory[]
  messages    Message[]
  user        User                @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("requests")
}

model RequestHistory {
  id        String        @id @default(cuid())
  requestId String
  status    RequestStatus
  note      String?
  createdAt DateTime      @default(now())
  request   Request       @relation(fields: [requestId], references: [id], onDelete: Cascade)

  @@map("request_history")
}

model RequestAttachment {
  id         String   @id @default(cuid())
  requestId  String
  fileName   String
  fileUrl    String
  fileSize   Int
  mimeType   String
  uploadedAt DateTime @default(now())
  request    Request  @relation(fields: [requestId], references: [id], onDelete: Cascade)

  @@map("request_attachments")
}

model TicketNote {
  id        String   @id @default(cuid())
  ticketId  String
  userId    String
  note      String
  createdAt DateTime @default(now())
  ticket    Ticket   @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("ticket_notes")
}

model Notification {
  id        String           @id @default(cuid())
  userId    String
  title     String
  message   String
  type      NotificationType @default(INFO)
  read      Boolean          @default(false)
  link      String?
  createdAt DateTime         @default(now())
  user      User             @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("notifications")
}

model WorkLog {
  id        String    @id @default(cuid())
  ticketId  String?
  userId    String
  startTime DateTime  @default(now())
  endTime   DateTime?
  duration  Int?
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  ticket    Ticket?   @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([ticketId])
  @@map("work_logs")
}

enum UserRole {
  ADMIN
  USER
  DEVELOPER
  TECHNICAL
}

enum NotificationType {
  INFO
  SUCCESS
  WARNING
  ERROR
}

enum BranchCategory {
  BRANCH
  BACK_OFFICE
  HYBRID
  DATA_CENTER
}

enum Priority {
  P1
  P2
  P3
}

enum TicketStatus {
  PENDING
  ACKNOWLEDGED
  IN_PROGRESS
  COMPLETED
  ESCALATED
  CLOSED
  INVOICE
  PAID
}

enum RequestStatus {
  PENDING
  APPROVED
  REJECTED
  IN_PROGRESS
  COMPLETED
}

// ==========================================
// COMPANY / MULTI-TENANT MODELS
// ==========================================

model Company {
  id          String    @id @default(cuid())
  name        String    @unique
  code        String    @unique  // Short code for identification
  isActive    Boolean   @default(true)
  parentId    String?   // For sub-companies
  parent      Company?  @relation("SubCompanies", fields: [parentId], references: [id])
  subCompanies Company[] @relation("SubCompanies")
  users       User[]    @relation("CompanyUsers")
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@index([parentId])
  @@map("companies")
}

// ==========================================
// CHAT SYSTEM MODELS
// ==========================================

model Conversation {
  id             String               @id @default(cuid())
  ticketId       String?              // Link to ticket (optional)
  requestId      String?              // Link to request (optional)
  title          String?              // Optional title for the conversation
  status         ConversationStatus   @default(ACTIVE)
  createdAt      DateTime             @default(now())
  updatedAt      DateTime             @updatedAt
  closedAt       DateTime?
  participants   ConversationParticipant[]
  messages       Message[]
  
  @@index([ticketId])
  @@index([requestId])
  @@index([status])
  @@map("conversations")
}

model ConversationParticipant {
  id             String       @id @default(cuid())
  conversationId String
  userId         String
  role           ParticipantRole @default(MEMBER)
  joinedAt       DateTime     @default(now())
  leftAt         DateTime?
  lastReadAt     DateTime?
  isTyping       Boolean      @default(false)
  typingUpdatedAt DateTime?
  clearedAt      DateTime?    // For "clearing" chat history without leaving
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  user           User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([conversationId, userId])
  @@index([userId])
  @@map("conversation_participants")
}

model Message {
  id             String       @id @default(cuid())
  conversationId String
  senderId       String
  content        String
  messageType    MessageType  @default(TEXT)
  status         MessageStatus @default(SENT)
  replyToId      String?      // For threaded replies
  ticketId       String?      // Reference to a ticket
  requestId      String?      // Reference to a request
  isEdited       Boolean      @default(false)
  editedAt       DateTime?
  deletedAt      DateTime?
  createdAt      DateTime     @default(now())
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  sender         User         @relation("MessageSender", fields: [senderId], references: [id], onDelete: Cascade)
  replyTo        Message?     @relation("MessageReplies", fields: [replyToId], references: [id])
  replies        Message[]    @relation("MessageReplies")
  ticket         Ticket?      @relation(fields: [ticketId], references: [id])
  request        Request?     @relation(fields: [requestId], references: [id])
  attachments    ChatAttachment[]
  readReceipts   MessageReadReceipt[]

  @@index([conversationId])
  @@index([senderId])
  @@index([createdAt])
  @@index([ticketId])
  @@index([requestId])
  @@map("messages")
}

model ChatAttachment {
  id         String   @id @default(cuid())
  messageId  String
  fileName   String
  fileUrl    String
  fileSize   Int
  mimeType   String
  uploadedAt DateTime @default(now())
  message    Message  @relation(fields: [messageId], references: [id], onDelete: Cascade)

  @@index([messageId])
  @@map("chat_attachments")
}

model MessageReadReceipt {
  id        String   @id @default(cuid())
  messageId String
  userId    String
  readAt    DateTime @default(now())
  message   Message  @relation(fields: [messageId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([messageId, userId])
  @@index([userId])
  @@map("message_read_receipts")
}

model UserPresence {
  id          String        @id @default(cuid())
  userId      String        @unique
  status      PresenceStatus @default(OFFLINE)
  lastSeenAt  DateTime      @default(now())
  socketId    String?       // Current socket connection ID
  updatedAt   DateTime      @updatedAt
  user        User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([status])
  @@map("user_presence")
}

model ChatAuditLog {
  id          String   @id @default(cuid())
  userId      String
  action      String   // SEND_MESSAGE, DELETE_MESSAGE, UPLOAD_FILE, etc.
  resourceType String  // CONVERSATION, MESSAGE, ATTACHMENT
  resourceId  String
  metadata    Json?    // Additional context data
  ipAddress   String?
  userAgent   String?
  createdAt   DateTime @default(now())

  @@index([userId])
  @@index([resourceType, resourceId])
  @@index([createdAt])
  @@map("chat_audit_logs")
}

// ==========================================
// CHAT ENUMS
// ==========================================

enum ConversationStatus {
  ACTIVE
  ARCHIVED
  CLOSED
}

enum ParticipantRole {
  ADMIN       // Can manage conversation
  MEMBER      // Regular participant
  OBSERVER    // Can only read
}

enum MessageType {
  TEXT
  FILE
  IMAGE
  SYSTEM      // System-generated messages
}

enum MessageStatus {
  SENDING
  SENT
  DELIVERED
  READ
  FAILED
}

enum PresenceStatus {
  ONLINE
  AWAY
  BUSY
  OFFLINE
}
